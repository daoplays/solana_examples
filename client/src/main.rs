pub mod utils;
pub mod state;

use std::env;
use std::str::FromStr;
use crate::state::{Result};

use solana_client::rpc_client::RpcClient;
use solana_program::{pubkey::Pubkey};
use solana_sdk::{
    signature::Keypair, signer::Signer,
    instruction::{AccountMeta, Instruction},
    transaction::Transaction, signer::keypair::read_keypair_file,
};
use borsh::{BorshDeserialize, BorshSerialize};
use solana_transaction_status::UiTransactionEncoding;
use rand::Rng;

#[derive(BorshDeserialize, BorshSerialize, Debug)]
pub struct State {
    pub random_numbers : [f64; 256]
}

#[derive(BorshSerialize, BorshDeserialize, Debug, Clone, PartialEq)]
pub enum RNGMethod {
    Xorshift,
    Hash
}

fn get_method_from_int(index: u64) -> RNGMethod {
    if index == 0 {
        return RNGMethod::Xorshift;
    } else {
        return RNGMethod::Hash;
    }

}

#[derive(BorshSerialize, BorshDeserialize, Debug, Clone, PartialEq)]
pub struct RNGMeta {
    pub initial_seed : u64,
    pub method : RNGMethod
}


#[derive(BorshSerialize, BorshDeserialize, Debug, Clone, PartialEq)]
pub enum RNGInstruction {

    GenerateRandom {
        metadata : RNGMeta
    }
}
const URL: &str = "https://api.devnet.solana.com";


fn main() {

    let args: Vec<String> = env::args().collect();
    let key_file = &args[1];
    let function = &args[2];

    if function == "init_data_account" {
        if let Err(err) = init_data_account(key_file) {
            eprintln!("{:?}", err);
            std::process::exit(1);
        }
    }
    else if function == "generate_randoms" {
        let index_arg = &args[3];
        let index: u64 = index_arg.parse().unwrap();
        let method = get_method_from_int(index);
        if let Err(err) = generate_randoms(key_file, method) {
            eprintln!("{:?}", err);
            std::process::exit(1);
        }
    }
    

}

pub fn create_data_account(
    creator: &Keypair,
    program: &Pubkey,
    connection: &RpcClient,
) -> Result<()> {

    let data_pubkey = Pubkey::create_with_seed(
        &creator.pubkey(),
        "rng_v1.0",
        program).unwrap();

        println!("data account pubkey: {:?}", data_pubkey);


    if let Err(_) = connection.get_account(&data_pubkey) {

        let lamport_requirement =
            connection.get_minimum_balance_for_rent_exemption(utils::get_state_size()?)?;

        // This instruction creates an account with the key
        // "data_pubkey". The created account is owned by the
        // program. The account is loaded with enough lamports to stop
        // it from needing to pay rent. The lamports to fund this are
        // paid by the creator.
        //
        // It is important that the program owns the created account
        // because it needs to be able to modify its contents.
        //
        // The address of the account created by
        // create_account_with_seed is the same as the address
        // generated by Pubkey::create_with_seed. This means the program or users can 
        // easily derive the same account if they have the right inputs to create_with_seed.
        let instruction = solana_sdk::system_instruction::create_account_with_seed(
            &creator.pubkey(),
            &data_pubkey,
            &creator.pubkey(),
            "rng_v1.0",
            lamport_requirement,
            utils::get_state_size()? as u64,
            &program,
        );

        let signers = [creator];
        let instructions = vec![instruction];
        let recent_hash = connection.get_latest_blockhash()?;
   
       let txn = Transaction::new_signed_with_payer(
           &instructions,
           Some(&creator.pubkey()),
           &signers,
           recent_hash,
       );

       let signature = connection.send_and_confirm_transaction(&txn)?;
        println!("signature: {}", signature);
        let response = connection.get_transaction(&signature, UiTransactionEncoding::Json)?;
        println!("result: {:#?}", response);
    }

    Ok(())
}

fn init_data_account(key_file: &String) ->Result<()> {

    // (2) Create a new Keypair for the new account
    let wallet = read_keypair_file(key_file).unwrap();

    // (3) Create RPC client to be used to talk to Solana cluster
    let connection = RpcClient::new(URL);

    let program = Pubkey::from_str("Dj75yJnPpACJdVLi5hgoEVXmQvteohEPPs4ezSkmjekc").unwrap();
  
    create_data_account(&wallet, &program, &connection)?;

    Ok(println!("Success!"))
}

fn generate_randoms(key_file: &String, method: RNGMethod) ->Result<()> {

    // (2) Create a new Keypair for the new account
    let wallet = read_keypair_file(key_file).unwrap();

    // (3) Create RPC client to be used to talk to Solana cluster
    let connection = RpcClient::new(URL);

    let program = Pubkey::from_str("Dj75yJnPpACJdVLi5hgoEVXmQvteohEPPs4ezSkmjekc").unwrap();
    let creator = Pubkey::from_str("FxVpjJ5AGY6cfCwZQP5v8QBfS4J2NPa62HbGh1Fu2LpD").unwrap();
    let data_account = Pubkey::create_with_seed(
        &creator,
        "rng_v1.0",
        &program).unwrap();

    let mut rng = rand::thread_rng();
    let seed: u64 = 1;//rng.gen();
    let meta_data =  RNGMeta{initial_seed: seed, method: method};


    let gen_randoms_idx = Instruction::new_with_borsh(
        program,
        &RNGInstruction::GenerateRandom{metadata : meta_data},
        vec![
            AccountMeta::new(data_account, false)
        ],
    );

    // (7) Build transaction wrapping the create account instruction signed by both accounts
    let signers = [&wallet];
    let instructions = vec![gen_randoms_idx];
    let recent_hash = connection.get_latest_blockhash()?;

    let txn = Transaction::new_signed_with_payer(
        &instructions,
        Some(&wallet.pubkey()),
        &signers,
        recent_hash,
    );

    // (8) Send transaction to the cluster and wait for confirmation
    let signature = connection.send_and_confirm_transaction(&txn)?;
    println!("signature: {}", signature);
    let response = connection.get_transaction(&signature, UiTransactionEncoding::Json)?;
    println!("result: {:#?}", response);

    let data = connection.get_account_data(&data_account)?;
    let state = State::try_from_slice(&data[..256*8]).unwrap();
    println!("data: {:#?}", state); 

    Ok(println!("Success!"))
}
