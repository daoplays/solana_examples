pub mod utils;
pub mod state;

use std::str::FromStr;
use crate::state::{Result};

use solana_client::rpc_client::RpcClient;
use solana_program::{pubkey::Pubkey, native_token::LAMPORTS_PER_SOL};
use solana_sdk::{
    signature::Keypair, signer::Signer,
    transaction::Transaction, signer::keypair::read_keypair_file,
};
use borsh::{BorshDeserialize, BorshSerialize};



#[derive(BorshSerialize, BorshDeserialize, Debug, Clone, PartialEq)]
pub struct RandomData {
    pub initial_seed: u64
}

#[derive(BorshSerialize, BorshDeserialize, Debug, Clone, PartialEq)]
pub struct BidData {
    pub amount: u64
}

#[derive(BorshSerialize, BorshDeserialize, Debug, Clone, PartialEq)]
pub enum RNGInstruction {

    GenerateRandom {
        initial_seed : u64
    }
}
const URL: &str = "https://api.devnet.solana.com";


fn main() {

    if let Err(err) = init_data_account() {
        eprintln!("{:?}", err);
        std::process::exit(1);
    }

}



/// On Solana accounts are ways to store data. In order to use our
/// greeting counter smart contract we need some way to store the
/// number of times we have said hello to the contract. To do this we
/// create a greeting account which we subsequentally transfer
/// ownership of to the program. This allows the program to write to
/// that account as it deems fit.
///
/// The greeting account has a [derived
/// address](https://docs.solana.com/developing/programming-model/calling-between-programs#program-derived-addresses)
/// which allows it to own and manage the account. Additionally the
/// address being derived means that we can regenerate it when we'd
/// like to find the greeting account again later.
pub fn create_data_account(
    creator: &Keypair,
    program: &Pubkey,
    connection: &RpcClient,
) -> Result<()> {

    let data_pubkey = Pubkey::create_with_seed(
        &creator.pubkey(),
        "rng_v1.0",
        program).unwrap();

        println!("data account pubkey: {:?}", data_pubkey);


    if let Err(_) = connection.get_account(&data_pubkey) {

        let lamport_requirement =
            connection.get_minimum_balance_for_rent_exemption(utils::get_state_size()?)?;

        println!("required rent for {}: {}", utils::get_state_size()?, lamport_requirement/LAMPORTS_PER_SOL);
        // This instruction creates an account with the key
        // "greeting_pubkey". The created account is owned by the
        // program. The account is loaded with enough lamports to stop
        // it from needing to pay rent. The lamports to fund this are
        // paid by the player.
        //
        // It is important that the program owns the created account
        // because it needs to be able to modify its contents.
        //
        // The address of the account created by
        // create_account_with_seed is the same as the address
        // generated by utils::get_greeting_public_key. We do this as
        // opposed to create_account because create account doesn't
        // derive that address like that.
        let instruction = solana_sdk::system_instruction::create_account_with_seed(
            &creator.pubkey(),
            &data_pubkey,
            &creator.pubkey(),
            "rng_v1.0",
            lamport_requirement,
            utils::get_state_size()? as u64,
            &program,
        );

        let signers = [creator];
        let instructions = vec![instruction];
        let recent_hash = connection.get_latest_blockhash()?;
   
       let txn = Transaction::new_signed_with_payer(
           &instructions,
           Some(&creator.pubkey()),
           &signers,
           recent_hash,
       );

       let response =  connection.send_and_confirm_transaction(&txn)?;
       println!("result: {}", response);
    }

    Ok(())
}

fn init_data_account() ->Result<()> {

    // (2) Create a new Keypair for the new account
    let wallet = read_keypair_file("/home/lindley/.config/solana/id.json").unwrap();

    // (3) Create RPC client to be used to talk to Solana cluster
    let connection = RpcClient::new(URL);

    let program = Pubkey::from_str("EvuPJ1NxTjzifoa6yEZEwYFw61sNb2J3se4eu7GGo7fw").unwrap();
  
    create_data_account(&wallet, &program, &connection);

    Ok(println!("Success!"))
}
